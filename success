Option Explicit

'=========================
' 設定（必要なら変更）
'=========================
Private Const SHEET_MASTER As String = "master"
Private Const SHEET_BEF    As String = "bef"
Private Const SHEET_AFT    As String = "aft"

Private Const HEADER_ROW As Long = 1       'ヘッダ行（PK1/PK2... がある行）
Private Const COMPARE_ROW As Long = 4      '比較FLG行（○/〇/◯）
Private Const DATA_START_ROW As Long = 5   'データ開始行

Private Const COL_PK As String = "PK"
Private Const COL_AFT_BEF As String = "aft_vs_bef"
Private Const COL_AFT_MST As String = "aft_vs_master"

' 出力ステータス（ユーザー要件に合わせて中国語）
Private Const STS_MATCH As String = "一致"
Private Const STS_NEW   As String = "新规"
Private Const STS_UPD   As String = "更新"
Private Const STS_DEL   As String = "删除"

' 色
Private Const COLOR_ROW_DIFF As Long = 255     '赤
Private Const COLOR_CELL_DIFF As Long = 65535  '黄

'=========================
' 入口：ボタンから呼ぶ
'=========================
Public Sub RunCompare()
    Application.ScreenUpdating = False
    Application.EnableEvents = False
    Application.Calculation = xlCalculationManual
    
    On Error GoTo EH
    
    Dim wsM As Worksheet, wsB As Worksheet, wsA As Worksheet
    Set wsM = ThisWorkbook.Worksheets(SHEET_MASTER)
    Set wsB = ThisWorkbook.Worksheets(SHEET_BEF)
    Set wsA = ThisWorkbook.Worksheets(SHEET_AFT)
    
    '0) 前回末尾に追記した「删除行」を削除（aftのみ）
    RemovePreviouslyAppendedDeleteRows wsA
    
    '1) 前回の生成物だけクリア（表頭は触らない）
    ClearGenerated wsM, False
    ClearGenerated wsB, False
    ClearGenerated wsA, True
    
    '2) PK列の確保＆再生成
    EnsurePK wsM
    EnsurePK wsB
    EnsurePK wsA
    
    '3) PKでソート
    SortByPK wsM
    SortByPK wsB
    SortByPK wsA
    
    '4) 比較対象列取得（aftの4行目に○/〇/◯）
    Dim cmpCols As Collection
    Set cmpCols = GetCompareColumns(wsA)
    If cmpCols.Count = 0 Then
        MsgBox "第" & COMPARE_ROW & "行目に「○/〇/◯」が付いた比較対象列が見つかりません。", vbExclamation
        GoTo EXIT_PROC
    End If
    
    '5) PK→行番号Map
    Dim mapM As Object, mapB As Object, mapA As Object
    Set mapM = BuildPKMap(wsM)
    Set mapB = BuildPKMap(wsB)
    Set mapA = BuildPKMap(wsA)
    
    '6) aftの末尾に結果2列を用意（無ければ追加）
    Dim colAB As Long, colAM As Long
    EnsureResultColumns wsA, colAB, colAM
    
    '7) aft中心で比較＆色＆コメント
    CompareAft wsA, wsB, wsM, mapA, mapB, mapM, cmpCols, colAB, colAM
    
    '8) 删除（相手に存在するがaftに無い）を aft 末尾に追記して可視化
    AppendDeletes wsA, mapB, mapA, colAB, "befにあり / aftに無し"
    AppendDeletes wsA, mapM, mapA, colAM, "masterにあり / aftに無し"
    
    MsgBox "比較が完了しました。", vbInformation

EXIT_PROC:
    Application.ScreenUpdating = True
    Application.EnableEvents = True
    Application.Calculation = xlCalculationAutomatic
    Exit Sub

EH:
    MsgBox "エラー：" & Err.Description, vbCritical
    Resume EXIT_PROC
End Sub

'=========================
' 前回生成物のクリア（表頭は触らない）
' - データ部の色/コメントをクリア
' - PK列の値をクリア
' - aftのみ：結果2列の値をクリア
'=========================
Private Sub ClearGenerated(ws As Worksheet, isAft As Boolean)
    Dim lastRowNum As Long, lastColNum As Long
    lastRowNum = GetLastRow(ws)
    lastColNum = GetLastCol(ws)
    If lastRowNum < DATA_START_ROW Then Exit Sub
    
    'データ部の色をクリア（表頭は触らない）
    With ws.Range(ws.Cells(DATA_START_ROW, 1), ws.Cells(lastRowNum, lastColNum))
        .Interior.Pattern = xlNone
    End With
    
    'データ部のコメントをクリア（表頭は触らない）
    Dim rng As Range
    On Error Resume Next
    Set rng = ws.Range(ws.Cells(DATA_START_ROW, 1), ws.Cells(lastRowNum, lastColNum)).SpecialCells(xlCellTypeComments)
    If Not rng Is Nothing Then rng.ClearComments
    On Error GoTo 0
    
    'PK列の値だけクリア
    Dim pkCol As Long
    pkCol = FindHeaderCol(ws, COL_PK)
    If pkCol > 0 Then
        ws.Range(ws.Cells(DATA_START_ROW, pkCol), ws.Cells(lastRowNum, pkCol)).ClearContents
    End If
    
    If isAft Then
        Dim c1 As Long, c2 As Long
        c1 = FindHeaderCol(ws, COL_AFT_BEF)
        c2 = FindHeaderCol(ws, COL_AFT_MST)
        If c1 > 0 Then ws.Range(ws.Cells(DATA_START_ROW, c1), ws.Cells(lastRowNum, c1)).ClearContents
        If c2 > 0 Then ws.Range(ws.Cells(DATA_START_ROW, c2), ws.Cells(lastRowNum, c2)).ClearContents
    End If
End Sub

'=========================
' PK列の確保＆生成
' - PK列が無い場合：
'   * 1列目のヘッダが空ならそこをPKにする
'   * 空でなければ1列目に挿入
' - PK値：ヘッダがPK1/PK2/PK3... の列を _ 連結
'=========================
Private Sub EnsurePK(ws As Worksheet)
    Dim pkCol As Long
    pkCol = FindHeaderCol(ws, COL_PK)
    
    If pkCol = 0 Then
        '1列目ヘッダが空ならそのまま使用、空でなければ挿入
        If Len(Trim$(CStr(ws.Cells(HEADER_ROW, 1).Value))) = 0 Then
            ws.Cells(HEADER_ROW, 1).Value = COL_PK
            pkCol = 1
        Else
            ws.Columns(1).Insert Shift:=xlToRight
            ws.Cells(HEADER_ROW, 1).Value = COL_PK
            pkCol = 1
        End If
    End If
    
    Dim pkSrcCols As Collection
    Set pkSrcCols = GetPKSourceColumns(ws)
    If pkSrcCols.Count = 0 Then
        Err.Raise vbObjectError + 101, , ws.Name & " に PK1/PK2/PK3... 列が見つかりません。"
    End If
    
    Dim lastRowNum As Long
    lastRowNum = GetLastRow(ws)
    If lastRowNum < DATA_START_ROW Then Exit Sub
    
    Dim r As Long
    For r = DATA_START_ROW To lastRowNum
        ws.Cells(r, pkCol).Value = BuildPKValue(ws, r, pkSrcCols)
    Next r
End Sub

Private Function GetPKSourceColumns(ws As Worksheet) As Collection
    Dim cols As New Collection
    Dim lastColNum As Long: lastColNum = GetLastCol(ws)
    
    Dim c As Long
    For c = 1 To lastColNum
        Dim h As String
        h = Trim$(CStr(ws.Cells(HEADER_ROW, c).Value))
        If Len(h) > 0 Then
            Dim u As String
            u = UCase$(h)
            If u Like "PK#" Or u Like "PK##" Or u Like "PK###" Then
                cols.Add c
            End If
        End If
    Next c
    
    Set GetPKSourceColumns = cols
End Function

Private Function BuildPKValue(ws As Worksheet, ByVal rowNum As Long, pkSrcCols As Collection) As String
    Dim i As Long, parts() As String
    ReDim parts(1 To pkSrcCols.Count)
    
    For i = 1 To pkSrcCols.Count
        parts(i) = Trim$(CStr(ws.Cells(rowNum, CLng(pkSrcCols(i))).Value))
    Next i
    
    BuildPKValue = Join(parts, "_")
End Function

'=========================
' PKでソート（表頭保持）
'=========================
Private Sub SortByPK(ws As Worksheet)
    Dim pkCol As Long: pkCol = FindHeaderCol(ws, COL_PK)
    If pkCol = 0 Then Exit Sub
    
    Dim lastRowNum As Long, lastColNum As Long
    lastRowNum = GetLastRow(ws)
    lastColNum = GetLastCol(ws)
    If lastRowNum < DATA_START_ROW Then Exit Sub
    
    Dim sortRange As Range
    Set sortRange = ws.Range(ws.Cells(HEADER_ROW, 1), ws.Cells(lastRowNum, lastColNum))
    
    With ws.Sort
        .SortFields.Clear
        .SortFields.Add Key:=ws.Range(ws.Cells(DATA_START_ROW, pkCol), ws.Cells(lastRowNum, pkCol)), _
                        SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
        .SetRange sortRange
        .Header = xlYes
        .Apply
    End With
End Sub

'=========================
' 比較対象列（4行目に○/〇/◯がある列）取得
'=========================
Private Function GetCompareColumns(ws As Worksheet) As Collection
    Dim cols As New Collection
    Dim lastColNum As Long: lastColNum = GetLastCol(ws)
    Dim pkCol As Long: pkCol = FindHeaderCol(ws, COL_PK)
    
    Dim c As Long
    For c = 1 To lastColNum
        If c <> pkCol Then
            Dim flag As String
            flag = CStr(ws.Cells(COMPARE_ROW, c).Value)
            If InStr(flag, "○") > 0 Or InStr(flag, "〇") > 0 Or InStr(flag, "◯") > 0 Then
                Dim h As String: h = Trim$(CStr(ws.Cells(HEADER_ROW, c).Value))
                If UCase$(h) <> UCase$(COL_AFT_BEF) And UCase$(h) <> UCase$(COL_AFT_MST) And UCase$(h) <> UCase$(COL_PK) Then
                    cols.Add c
                End If
            End If
        End If
    Next c
    
    Set GetCompareColumns = cols
End Function

'=========================
' PK→行番号Map
'=========================
Private Function BuildPKMap(ws As Worksheet) As Object
    Dim dict As Object: Set dict = CreateObject("Scripting.Dictionary")
    dict.CompareMode = 1 'TextCompare
    
    Dim pkCol As Long: pkCol = FindHeaderCol(ws, COL_PK)
    If pkCol = 0 Then
        Set BuildPKMap = dict
        Exit Function
    End If
    
    Dim lastRowNum As Long: lastRowNum = GetLastRow(ws)
    Dim r As Long
    For r = DATA_START_ROW To lastRowNum
        Dim pk As String
        pk = Trim$(CStr(ws.Cells(r, pkCol).Value))
        If Len(pk) > 0 Then
            If Not dict.Exists(pk) Then dict.Add pk, r
        End If
    Next r
    
    Set BuildPKMap = dict
End Function

'=========================
' aftの結果2列を確保（無ければ末尾に追加）
'=========================
Private Sub EnsureResultColumns(wsA As Worksheet, ByRef colAB As Long, ByRef colAM As Long)
    colAB = FindHeaderCol(wsA, COL_AFT_BEF)
    colAM = FindHeaderCol(wsA, COL_AFT_MST)
    
    Dim lastColNum As Long: lastColNum = GetLastCol(wsA)
    
    If colAB = 0 Then
        lastColNum = lastColNum + 1
        wsA.Cells(HEADER_ROW, lastColNum).Value = COL_AFT_BEF
        colAB = lastColNum
    End If
    
    If colAM = 0 Then
        lastColNum = GetLastCol(wsA) + 1
        wsA.Cells(HEADER_ROW, lastColNum).Value = COL_AFT_MST
        colAM = lastColNum
    End If
End Sub

'=========================
' 比較（aft中心）
'=========================
Private Sub CompareAft(wsA As Worksheet, wsB As Worksheet, wsM As Worksheet, _
                      mapA As Object, mapB As Object, mapM As Object, _
                      cmpCols As Collection, colAB As Long, colAM As Long)
    
    Dim pkColA As Long: pkColA = FindHeaderCol(wsA, COL_PK)
    Dim lastRowA As Long: lastRowA = GetLastRow(wsA)
    If lastRowA < DATA_START_ROW Then Exit Sub
    
    Dim rA As Long
    For rA = DATA_START_ROW To lastRowA
        Dim pk As String
        pk = Trim$(CStr(wsA.Cells(rA, pkColA).Value))
        If Len(pk) = 0 Then GoTo NextRow
        
        Dim stAB As String, stAM As String
        stAB = CompareOne(wsA, rA, wsB, mapB, pk, cmpCols)
        stAM = CompareOne(wsA, rA, wsM, mapM, pk, cmpCols)
        
        wsA.Cells(rA, colAB).Value = stAB
        wsA.Cells(rA, colAM).Value = stAM
        
        '行を赤（どちらかが一致以外）
        If stAB <> STS_MATCH Or stAM <> STS_MATCH Then
            wsA.Rows(rA).Interior.Color = COLOR_ROW_DIFF
        End If
        
        '差分セルを黄＋コメント（aftに付ける）
        HighlightDiffCells wsA, rA, wsB, mapB, wsM, mapM, pk, cmpCols
        
NextRow:
    Next rA
End Sub

Private Function CompareOne(wsA As Worksheet, rA As Long, wsX As Worksheet, mapX As Object, _
                            pk As String, cmpCols As Collection) As String
    '相手に無い → 新规
    If Not mapX.Exists(pk) Then
        CompareOne = STS_NEW
        Exit Function
    End If
    
    Dim rX As Long: rX = CLng(mapX(pk))
    Dim i As Long
    For i = 1 To cmpCols.Count
        Dim c As Long: c = CLng(cmpCols(i))
        Dim aVal As String, xVal As String
        aVal = NormalizeValue(wsA.Cells(rA, c).Value)
        xVal = NormalizeValue(wsX.Cells(rX, c).Value)
        If aVal <> xVal Then
            CompareOne = STS_UPD '差分あり → 更新
            Exit Function
        End If
    Next i
    
    CompareOne = STS_MATCH
End Function

Private Sub HighlightDiffCells(wsA As Worksheet, rA As Long, wsB As Worksheet, mapB As Object, _
                              wsM As Worksheet, mapM As Object, pk As String, cmpCols As Collection)
    Dim hasB As Boolean: hasB = mapB.Exists(pk)
    Dim hasM As Boolean: hasM = mapM.Exists(pk)
    
    Dim rB As Long, rM As Long
    If hasB Then rB = CLng(mapB(pk))
    If hasM Then rM = CLng(mapM(pk))
    
    Dim i As Long
    For i = 1 To cmpCols.Count
        Dim c As Long: c = CLng(cmpCols(i))
        
        Dim vA As String, vB As String, vM As String
        vA = NormalizeValue(wsA.Cells(rA, c).Value)
        vB = IIf(hasB, NormalizeValue(wsB.Cells(rB, c).Value), "（不存在）")
        vM = IIf(hasM, NormalizeValue(wsM.Cells(rM, c).Value), "（不存在）")
        
        If (vA <> vB) Or (vA <> vM) Or (vB <> vM) Then
            With wsA.Cells(rA, c)
                .Interior.Color = COLOR_CELL_DIFF
                On Error Resume Next
                .ClearComments
                On Error GoTo 0
                .AddComment "bef: " & vB & vbCrLf & "aft: " & vA & vbCrLf & "master: " & vM
            End With
        End If
    Next i
End Sub

'=========================
' 删除（相手にあるがaftに無い）を aft 末尾に追記して見える化
'=========================
Private Sub AppendDeletes(wsA As Worksheet, mapX As Object, mapA As Object, resultCol As Long, note As String)
    Dim pkColA As Long: pkColA = FindHeaderCol(wsA, COL_PK)
    Dim lastRowNum As Long: lastRowNum = GetLastRow(wsA)
    
    Dim k As Variant
    For Each k In mapX.Keys
        If Not mapA.Exists(CStr(k)) Then
            lastRowNum = lastRowNum + 1
            wsA.Cells(lastRowNum, pkColA).Value = CStr(k)
            wsA.Cells(lastRowNum, resultCol).Value = STS_DEL
            
            wsA.Rows(lastRowNum).Interior.Color = COLOR_ROW_DIFF
            
            On Error Resume Next
            wsA.Cells(lastRowNum, pkColA).ClearComments
            On Error GoTo 0
            wsA.Cells(lastRowNum, pkColA).AddComment note
        End If
    Next k
End Sub

'=========================
' 前回末尾に追記した「删除行」を削除
' 条件：
' - 結果列に「删除」が入っている
' - PK以外（結果列含む）ほぼ空の行を対象に下から削除
'=========================
Private Sub RemovePreviouslyAppendedDeleteRows(wsA As Worksheet)
    Dim colAB As Long: colAB = FindHeaderCol(wsA, COL_AFT_BEF)
    Dim colAM As Long: colAM = FindHeaderCol(wsA, COL_AFT_MST)
    If colAB = 0 And colAM = 0 Then Exit Sub
    
    Dim pkCol As Long: pkCol = FindHeaderCol(wsA, COL_PK)
    If pkCol = 0 Then Exit Sub
    
    Dim lastRowNum As Long: lastRowNum = GetLastRow(wsA)
    Dim lastColNum As Long: lastColNum = GetLastCol(wsA)
    If lastRowNum < DATA_START_ROW Then Exit Sub
    
    Dim r As Long
    For r = lastRowNum To DATA_START_ROW Step -1
        Dim st1 As String, st2 As String
        st1 = IIf(colAB > 0, Trim$(CStr(wsA.Cells(r, colAB).Value)), "")
        st2 = IIf(colAM > 0, Trim$(CStr(wsA.Cells(r, colAM).Value)), "")
        
        If (st1 = STS_DEL Or st2 = STS_DEL) Then
            Dim c As Long, allBlank As Boolean
            allBlank = True
            
            For c = 1 To lastColNum
                'PK列と結果列は除外して空チェック
                If c <> pkCol And c <> colAB And c <> colAM Then
                    If Len(Trim$(CStr(wsA.Cells(r, c).Value))) > 0 Then
                        allBlank = False
                        Exit For
                    End If
                End If
            Next c
            
            If allBlank Then
                wsA.Rows(r).Delete
            End If
        End If
    Next r
End Sub

'=========================
' Utility
'=========================
Private Function FindHeaderCol(ws As Worksheet, headerName As String) As Long
    Dim lastColNum As Long: lastColNum = GetLastCol(ws)
    Dim c As Long
    For c = 1 To lastColNum
        If UCase$(Trim$(CStr(ws.Cells(HEADER_ROW, c).Value))) = UCase$(headerName) Then
            FindHeaderCol = c
            Exit Function
        End If
    Next c
    FindHeaderCol = 0
End Function

Private Function GetLastRow(ws As Worksheet) As Long
    On Error Resume Next
    Dim f As Range
    Set f = ws.Cells.Find(What:="*", After:=ws.Cells(1, 1), LookIn:=xlFormulas, _
                          LookAt:=xlPart, SearchOrder:=xlByRows, SearchDirection:=xlPrevious)
    If f Is Nothing Then
        GetLastRow = HEADER_ROW
    Else
        GetLastRow = f.Row
    End If
    On Error GoTo 0
End Function

Private Function GetLastCol(ws As Worksheet) As Long
    On Error Resume Next
    Dim f As Range
    Set f = ws.Cells.Find(What:="*", After:=ws.Cells(1, 1), LookIn:=xlFormulas, _
                          LookAt:=xlPart, SearchOrder:=xlByColumns, SearchDirection:=xlPrevious)
    If f Is Nothing Then
        GetLastCol = 1
    Else
        GetLastCol = f.Column
    End If
    On Error GoTo 0
End Function

Private Function NormalizeValue(v As Variant) As String
    If IsError(v) Then
        NormalizeValue = "#ERROR"
    ElseIf IsEmpty(v) Then
        NormalizeValue = ""
    Else
        NormalizeValue = Trim$(CStr(v))
    End If
End Function
