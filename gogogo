Option Explicit

'==== シート名 ====
Private Const SHEET_AFT As String = "aft"
Private Const SHEET_BEF As String = "bef"
Private Const SHEET_MAS As String = "master"

'==== 追加ヘッダ ====
Private Const HDR_PKKEY As String = "PK_KEY"
Private Const HDR_BEF_RES As String = "Bef-Aft 判定結果"
Private Const HDR_MAS_RES As String = "Aft-Master 判定結果"

'==== 内部列（隠す） ====
Private Const HDR_BEF_ROW As String = "BEF_ROW"
Private Const HDR_MAS_ROW As String = "MAS_ROW"
Private Const HDR_CHK_BEF As String = "CHK_BEF_"
Private Const HDR_CHK_MAS As String = "CHK_MAS_"

'==== 1グループの比較列数（ここを調整可）====
Private Const CHUNK_SIZE As Long = 20

'==================================================
' メイン入口
'==================================================
Public Sub RunDiffCheck()
    Dim wsAft As Worksheet, wsBef As Worksheet, wsMas As Worksheet
    Set wsAft = Sheets(SHEET_AFT)
    Set wsBef = Sheets(SHEET_BEF)
    Set wsMas = Sheets(SHEET_MAS)

    Application.ScreenUpdating = False
    Application.Calculation = xlCalculationManual
    Application.EnableEvents = False
    On Error GoTo EH

    If wsAft.ProtectContents Then Err.Raise vbObjectError + 100, , "aft が保護されています。解除してください。"
    If wsBef.ProtectContents Then Err.Raise vbObjectError + 101, , "bef が保護されています。解除してください。"
    If wsMas.ProtectContents Then Err.Raise vbObjectError + 102, , "master が保護されています。解除してください。"

    ClearOldResult_KeepHeaderFormats wsAft

    Dim baseCol As Long
    baseCol = GetBaseColStable(wsAft)

    Dim pkCols As Collection, cmpCols As Collection
    Set pkCols = GetPKColumns(wsAft, baseCol)
    Set cmpCols = GetCompareColumns(wsAft, baseCol)

    If pkCols.Count = 0 Then Err.Raise vbObjectError + 1, , "PK列（3行目）が検出できません。"
    If cmpCols.Count = 0 Then Err.Raise vbObjectError + 2, , "比較対象列（4行目）が検出できません。"

    '==== 結果列（見える位置：baseCol+1/+2）====
    Dim colResBef As Long, colResMas As Long
    colResBef = EnsureHeaderAt(wsAft, baseCol + 1, HDR_BEF_RES)
    colResMas = EnsureHeaderAt(wsAft, baseCol + 2, HDR_MAS_RES)

    '==== PK_KEY（値直書き）====
    Dim colKeyAft As Long, colKeyBef As Long, colKeyMas As Long
    colKeyAft = EnsurePKKeyAt_ValueWrite(wsAft, baseCol + 3, pkCols)
    colKeyBef = EnsurePKKeyAt_ValueWrite(wsBef, GetBaseColStable(wsBef) + 1, pkCols)
    colKeyMas = EnsurePKKeyAt_ValueWrite(wsMas, GetBaseColStable(wsMas) + 1, pkCols)

    '==== 行番号ヘルパ列（MATCHを1回だけ）====
    Dim colBefRow As Long, colMasRow As Long
    colBefRow = EnsureHeaderAt(wsAft, baseCol + 4, HDR_BEF_ROW)
    colMasRow = EnsureHeaderAt(wsAft, baseCol + 5, HDR_MAS_ROW)

    wsAft.Columns(colKeyAft).Hidden = True
    wsAft.Columns(colBefRow).Hidden = True
    wsAft.Columns(colMasRow).Hidden = True

    '==== 判定用の式生成（分割）====
    GenerateAllFormulas_Splitted wsAft, wsBef, wsMas, cmpCols, _
                                 colKeyAft, colKeyBef, colKeyMas, _
                                 colBefRow, colMasRow, _
                                 colResBef, colResMas

    Application.Calculate

    '==== 標紅＋コメント（bef/aft/master）====
    ApplyHighlightsAndComments wsAft, wsBef, wsMas, cmpCols, colKeyAft, colKeyBef, colKeyMas

    wsAft.Activate
    wsAft.Cells(5, colResBef).Select

    Application.EnableEvents = True
    Application.Calculation = xlCalculationAutomatic
    Application.ScreenUpdating = True

    MsgBox "完了しました。", vbInformation
    Exit Sub

EH:
    Application.EnableEvents = True
    Application.Calculation = xlCalculationAutomatic
    Application.ScreenUpdating = True
    MsgBox "エラー: " & Err.Number & vbCrLf & Err.Description, vbCritical
End Sub

'==================================================
' baseCol を安定取得（1～4行 + UsedRange）
'==================================================
Private Function GetBaseColStable(ws As Worksheet) As Long
    Dim c1 As Long, c2 As Long, c3 As Long, c4 As Long, cu As Long
    c1 = ws.Cells(1, ws.Columns.Count).End(xlToLeft).Column
    c2 = ws.Cells(2, ws.Columns.Count).End(xlToLeft).Column
    c3 = ws.Cells(3, ws.Columns.Count).End(xlToLeft).Column
    c4 = ws.Cells(4, ws.Columns.Count).End(xlToLeft).Column
    cu = ws.UsedRange.Column + ws.UsedRange.Columns.Count - 1
    GetBaseColStable = WorksheetFunction.Max(c1, c2, c3, c4, cu)
End Function

'==================================================
' 旧結果クリア（1～4行は保持）
'==================================================
Private Sub ClearOldResult_KeepHeaderFormats(ws As Worksheet)
    Dim lastRow As Long, lastCol As Long
    lastRow = ws.Cells(ws.Rows.Count, 1).End(xlUp).Row
    lastCol = ws.Cells(1, ws.Columns.Count).End(xlToLeft).Column
    If lastRow >= 5 Then
        ws.Range(ws.Cells(5, 1), ws.Cells(lastRow, lastCol)).Interior.ColorIndex = xlNone
        On Error Resume Next
        ws.Range(ws.Cells(5, 1), ws.Cells(lastRow, lastCol)).ClearComments
        On Error GoTo 0
    End If
End Sub

Private Function EnsureHeaderAt(ws As Worksheet, colIndex As Long, header As String) As Long
    ws.Cells(1, colIndex).Value = header
    EnsureHeaderAt = colIndex
End Function

'==================================================
' PK列（3行目）
'==================================================
Private Function GetPKColumns(ws As Worksheet, lastCol As Long) As Collection
    Dim col As New Collection, c As Long
    For c = 1 To lastCol
        If Trim(ws.Cells(3, c).Value) <> "" Then col.Add c
    Next
    Set GetPKColumns = col
End Function

'==================================================
' 比較対象列（4行目）
'==================================================
Private Function GetCompareColumns(ws As Worksheet, lastCol As Long) As Collection
    Dim col As New Collection, c As Long
    For c = 1 To lastCol
        If Trim(ws.Cells(4, c).Value) <> "" Then col.Add c
    Next
    Set GetCompareColumns = col
End Function

'==================================================
' PK_KEY（値直書き・非表示）
'==================================================
Private Function EnsurePKKeyAt_ValueWrite(ws As Worksheet, colKey As Long, pkCols As Collection) As Long
    ws.Cells(1, colKey).Value = HDR_PKKEY
    ws.Cells(2, colKey).Value = ""
    ws.Cells(3, colKey).Value = ""
    ws.Cells(4, colKey).Value = ""

    Dim lastRow As Long, r As Long
    lastRow = ws.Cells(ws.Rows.Count, 1).End(xlUp).Row
    If lastRow >= 5 Then
        For r = 5 To lastRow
            ws.Cells(r, colKey).Value = BuildPKKeyValue(ws, r, pkCols)
        Next r
    End If

    ws.Columns(colKey).Hidden = True
    EnsurePKKeyAt_ValueWrite = colKey
End Function

Private Function BuildPKKeyValue(ws As Worksheet, r As Long, pkCols As Collection) As String
    Dim key As String, c As Variant
    For Each c In pkCols
        key = key & Trim(CStr(ws.Cells(r, CLng(c)).Value)) & "|"
    Next
    If Len(key) > 0 Then key = Left$(key, Len(key) - 1)
    BuildPKKeyValue = key
End Function

'==================================================
' すべての式を「分割」して生成（1004回避）
'==================================================
Private Sub GenerateAllFormulas_Splitted( _
    wsAft As Worksheet, wsBef As Worksheet, wsMas As Worksheet, _
    cmpCols As Collection, _
    colKeyAft As Long, colKeyBef As Long, colKeyMas As Long, _
    colBefRow As Long, colMasRow As Long, _
    colResBef As Long, colResMas As Long)

    Dim lastRowAft As Long: lastRowAft = wsAft.Cells(wsAft.Rows.Count, 1).End(xlUp).Row
    If lastRowAft < 5 Then Exit Sub

    Dim lastRowBef As Long: lastRowBef = wsBef.Cells(wsBef.Rows.Count, 1).End(xlUp).Row
    Dim lastRowMas As Long: lastRowMas = wsMas.Cells(wsMas.Rows.Count, 1).End(xlUp).Row

    Dim sep As String: sep = Application.International(xlListSeparator)

    '--- BEF_ROW / MAS_ROW ---
    Dim r As Long
    For r = 5 To lastRowAft
        wsAft.Cells(r, colBefRow).Formula = "=IFERROR(MATCH(" & wsAft.Cells(r, colKeyAft).Address(False, False) & _
                                           sep & "'" & wsBef.Name & "'!" & wsBef.Range(wsBef.Cells(5, colKeyBef), wsBef.Cells(lastRowBef, colKeyBef)).Address & _
                                           sep & "0),0)"
        wsAft.Cells(r, colMasRow).Formula = "=IFERROR(MATCH(" & wsAft.Cells(r, colKeyAft).Address(False, False) & _
                                           sep & "'" & wsMas.Name & "'!" & wsMas.Range(wsMas.Cells(5, colKeyMas), wsMas.Cells(lastRowMas, colKeyMas)).Address & _
                                           sep & "0),0)"
    Next r

    '--- 比較列を CHUNK_SIZE ごとに分割して CHK列を作る ---
    Dim n As Long: n = cmpCols.Count
    Dim chunks As Long: chunks = (n + CHUNK_SIZE - 1) \ CHUNK_SIZE

    Dim i As Long
    Dim colChkBefStart As Long, colChkMasStart As Long
    colChkBefStart = colMasRow + 1
    colChkMasStart = colMasRow + 1 + chunks

    ' ヘッダ
    For i = 1 To chunks
        wsAft.Cells(1, colChkBefStart + i - 1).Value = HDR_CHK_BEF & i
        wsAft.Cells(1, colChkMasStart + i - 1).Value = HDR_CHK_MAS & i
        wsAft.Columns(colChkBefStart + i - 1).Hidden = True
        wsAft.Columns(colChkMasStart + i - 1).Hidden = True
    Next i

    ' CHK式作成
    For r = 5 To lastRowAft
        For i = 1 To chunks
            wsAft.Cells(r, colChkBefStart + i - 1).Formula = _
                BuildChunkDiffFormula(wsAft, wsBef, r, cmpCols, (i - 1) * CHUNK_SIZE + 1, i * CHUNK_SIZE, colBefRow, 5, lastRowBef, sep)

            wsAft.Cells(r, colChkMasStart + i - 1).Formula = _
                BuildChunkDiffFormula(wsAft, wsMas, r, cmpCols, (i - 1) * CHUNK_SIZE + 1, i * CHUNK_SIZE, colMasRow, 5, lastRowMas, sep)
        Next i
    Next r

    '--- 最終判定（短い式）---
    For r = 5 To lastRowAft
        wsAft.Cells(r, colResBef).Formula = BuildFinalJudgeFormula(wsAft, r, colBefRow, colChkBefStart, chunks, sep)
        wsAft.Cells(r, colResMas).Formula = BuildFinalJudgeFormula(wsAft, r, colMasRow, colChkMasStart, chunks, sep)
    Next r

End Sub

' 1チャンク分の差分チェック式（TRUE/FALSE）
Private Function BuildChunkDiffFormula( _
    wsAft As Worksheet, wsCmp As Worksheet, _
    aftRow As Long, cmpCols As Collection, _
    startIdx As Long, endIdx As Long, _
    rowNumCol As Long, cmpStartRow As Long, cmpEndRow As Long, _
    sep As String) As String

    Dim f As String
    Dim sumExpr As String: sumExpr = ""

    Dim idx As Long
    Dim colNo As Long
    Dim aftCell As String, cmpRange As String, idxExpr As String

    If endIdx > cmpCols.Count Then endIdx = cmpCols.Count
    If startIdx > cmpCols.Count Then
        BuildChunkDiffFormula = "=FALSE"
        Exit Function
    End If

    For idx = startIdx To endIdx
        colNo = CLng(cmpCols(idx))
        aftCell = wsAft.Cells(aftRow, colNo).Address(False, False)
        cmpRange = "'" & wsCmp.Name & "'!" & wsCmp.Range(wsCmp.Cells(cmpStartRow, colNo), wsCmp.Cells(cmpEndRow, colNo)).Address

        ' INDEX(範囲, rowNum) ※ rowNum は「範囲内の相対行」なので (rowNumCol) をそのまま使える（MATCH結果は範囲基準）
        idxExpr = "INDEX(" & cmpRange & sep & wsAft.Cells(aftRow, rowNumCol).Address(False, False) & ")"

        sumExpr = sumExpr & "--(TRIM(" & """" & """&" & aftCell & ")<>TRIM(" & """" & """&" & idxExpr & "))+"
    Next idx

    If Len(sumExpr) = 0 Then
        BuildChunkDiffFormula = "=FALSE"
        Exit Function
    End If

    sumExpr = Left$(sumExpr, Len(sumExpr) - 1)

    ' rowNum=0（見つからない）なら FALSE（差分ではなく新規扱い）
    f = "=IF(" & wsAft.Cells(aftRow, rowNumCol).Address(False, False) & "=0,FALSE,(" & sumExpr & ")>0)"
    BuildChunkDiffFormula = f
End Function

' 最終判定式（新規/変更/OK）
Private Function BuildFinalJudgeFormula( _
    ws As Worksheet, r As Long, rowNumCol As Long, chkStartCol As Long, chunks As Long, sep As String) As String

    Dim orExpr As String, i As Long
    orExpr = ""
    For i = 0 To chunks - 1
        orExpr = orExpr & ws.Cells(r, chkStartCol + i).Address(False, False) & sep
    Next i
    orExpr = Left$(orExpr, Len(orExpr) - Len(sep))

    BuildFinalJudgeFormula = "=IF(" & ws.Cells(r, rowNumCol).Address(False, False) & "=0,""新規"",IF(OR(" & orExpr & "),""変更"",""OK""))"
End Function

'==================================================
' 標紅＋コメント（bef/aft/master）
'==================================================
Private Sub ApplyHighlightsAndComments( _
    wsAft As Worksheet, wsBef As Worksheet, wsMas As Worksheet, _
    cmpCols As Collection, _
    colKeyAft As Long, colKeyBef As Long, colKeyMas As Long)

    Dim mapBef As Object, mapMas As Object
    Set mapBef = CreateObject("Scripting.Dictionary")
    Set mapMas = CreateObject("Scripting.Dictionary")
    BuildKeyRowMap wsBef, colKeyBef, mapBef
    BuildKeyRowMap wsMas, colKeyMas, mapMas

    Dim lastRowAft As Long: lastRowAft = wsAft.Cells(wsAft.Rows.Count, 1).End(xlUp).Row
    If lastRowAft < 5 Then Exit Sub

    Dim r As Long, c As Variant
    For r = 5 To lastRowAft
        Dim key As String, befRow As Long, masRow As Long
        key = CStr(wsAft.Cells(r, colKeyAft).Value)
        befRow = IIf(mapBef.Exists(key), CLng(mapBef(key)), 0)
        masRow = IIf(mapMas.Exists(key), CLng(mapMas(key)), 0)

        For Each c In cmpCols
            Dim aftVal As String, befVal As String, masVal As String
            aftVal = Norm(wsAft.Cells(r, CLng(c)).Value)
            befVal = IIf(befRow > 0, Norm(wsBef.Cells(befRow, CLng(c)).Value), "(なし)")
            masVal = IIf(masRow > 0, Norm(wsMas.Cells(masRow, CLng(c)).Value), "(なし)")

            Dim diffBef As Boolean, diffMas As Boolean
            diffBef = (befRow > 0 And aftVal <> befVal)
            diffMas = (masRow > 0 And aftVal <> masVal)

            If diffBef Or diffMas Then
                With wsAft.Cells(r, CLng(c))
                    .Interior.Color = RGB(255, 180, 180)
                    On Error Resume Next
                    .ClearComments
                    On Error GoTo 0
                    .AddComment "bef : " & befVal & vbCrLf & "aft : " & aftVal & vbCrLf & "master : " & masVal
                End With
            End If
        Next c
    Next r
End Sub

Private Sub BuildKeyRowMap(ws As Worksheet, colKey As Long, dict As Object)
    dict.RemoveAll
    Dim lastRow As Long, r As Long, k As String
    lastRow = ws.Cells(ws.Rows.Count, 1).End(xlUp).Row
    If lastRow < 5 Then Exit Sub
    For r = 5 To lastRow
        k = CStr(ws.Cells(r, colKey).Value)
        If Len(k) > 0 Then If Not dict.Exists(k) Then dict.Add k, r
    Next r
End Sub

Private Function Norm(v As Variant) As String
    If IsError(v) Then
        Norm = "#ERR"
    Else
        Norm = Trim(CStr(v))
    End If
End Function
